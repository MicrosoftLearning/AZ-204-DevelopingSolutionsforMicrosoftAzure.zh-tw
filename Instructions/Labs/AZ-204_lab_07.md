---
lab:
  az204Title: 'Lab 07: Access resource secrets more securely across services'
  az020Title: 'Lab 07: Access resource secrets more securely across services'
  az204Module: 'Module 07: Implement secure cloud solutions'
  az020Module: 'Module 07: Implement secure cloud solutions'
ms.openlocfilehash: 9638ad805940d8343646cd2790f2b6a06d9952df
ms.sourcegitcommit: 9abfe3b5a1c9ccd2f0610348052d04169573f81a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/01/2022
ms.locfileid: "145994986"
---
# <a name="lab-07-access-resource-secrets-more-securely-across-services"></a>實驗 07：在各服務間更安全地存取資源祕密

## <a name="microsoft-azure-user-interface"></a>Microsoft Azure 使用者介面

基於 Microsoft 雲端工具的動態性質，您可能會遇到在本訓練內容開發後變更的 Azure UI。 因此，實驗指示可能無法正確對應實驗步驟。

當社群提醒 Microsoft 需要做修改時，我們會更新此訓練課程。 然而，由於雲端經常更新，因此您可能會在此訓練內容更新前遇到 UI 的變更。 **如果發生這種情況，請適應變更，然後視需要在實驗中調整。**

## <a name="instructions"></a>指示

### <a name="before-you-start"></a>在您開始使用 Intune 之前

#### <a name="sign-in-to-the-lab-environment"></a>登入實驗室環境

使用下列認證登入您的 Windows 10 虛擬機器 (VM)：

- 使用者名稱：**系統管理員**
- 密碼：**Pa55w.rd**

> **注意**：您的講師會提供連線至虛擬實驗室環境的指示。

#### <a name="review-the-installed-applications"></a>檢閱已安裝的應用程式

尋找 Windows 10 桌面上的工作列。 工作列包含此次實驗中會用到的應用程式圖示，包括：

- Microsoft Edge
- 檔案總管
- Windows 終端機
- Visual Studio Code

## <a name="architecture-diagram"></a>架構圖

![說明使用者在各服務間更安全地存取資源祕密的結構圖。](./media/Lab07-Diagram.png)

### <a name="exercise-1-create-azure-resources"></a>練習 1：建立 Azure 資源

#### <a name="task-1-open-the-azure-portal"></a>工作 1：開啟 Azure 入口網站

1. 在工作列上，選取 **Microsoft Edge** 圖示。

1. 在開啟的瀏覽器視窗中，瀏覽至 Azure 入口網站 (<https://portal.azure.com>)，然後登入您在此實驗要用的帳戶。

    > **注意**：如果這是您第一次登入 Azure 入口網站，系統會提供入口網站的導覽。 選取 [開始使用] 跳過導覽，並開始使用入口網站。

#### <a name="task-2-create-a-storage-account"></a>工作 2：建立儲存體帳戶

1. 在 Azure 入口網站中，使用 [搜尋資源、服務和文件] 文字輸入框，來搜尋 [儲存體帳戶]，然後在結果清單中選取 [儲存體帳戶]。

1. 在 [儲存體帳戶] 刀鋒視窗上，選取 [+ 建立]。

1. 在 [建立儲存體帳戶] 窗格的 [基本] 索引標籤上，執行下列動作，然後選取 [檢閱 + 建立]：

   | 設定 | 動作 |
   | --- | --- |
   | [訂閱] 下拉式清單   | 保留預設值 |
   | [資源群組] 區段        | 選取 [新建]，輸入 **ConfidentialStack**，然後選取 [確定] |
   | [儲存體帳戶名稱] 文字輸入框 | 輸入 **securestor**[您的名稱] |
   | [區域] 下拉式清單         | 選取 **(美國) 美國東部** |
   | [效能] 區段           | 選取 [標準] 選項 |
   | [備援] 下拉式清單     | 選取 [本地備援儲存體 (LRS)] |

   下列螢幕擷取畫面顯示 [建立儲存體帳戶] 窗格上的設定。

   ![顯示 [建立儲存體帳戶] 窗格中設定的螢幕擷取畫面](./media/l07_create_a_storage_account.png)

1. 在 [檢閱 + 建立] 索引標籤上，檢閱在先前步驟中選取的選項。

1. 選取 [建立]，使用您指定的設定來建立儲存體帳戶。

    > **注意**：等候建立工作完成，再繼續進行實驗。

1. 在 [部署概觀] 窗格上，選取 [前往資源]。

1. 在 [儲存體帳戶] 窗格的 [安全性 + 網路] 區段中選取 [存取金鑰] 連結。

1. 在 [存取金鑰] 區段中，選取 [顯示金鑰]。

1. 選取任一金鑰，並紀錄其中一個 [連接字串] 方塊中的值。 您會在稍後的實驗中用到此值。

    > **注意**：無論您選擇哪個連接字串都不會有影響。 這些連接字串是可以互相交換的。

#### <a name="task-3-create-an-azure-key-vault"></a>工作 3：建立 Azure Key Vault

1. 在 Azure 入口網站中，使用 [搜尋資源、服務和文件] 文字輸入框，搜尋 **金鑰保存庫**，然後在結果清單中選取 [金鑰保存庫]。

1. 在 [金鑰保存庫] 窗格上，選取 [建立]。

1.  在 [建立金鑰保存庫] 窗格的 [基本] 索引標籤上，執行下列動作，然後選取 [檢閱 + 建立]：

    | 設定                           | 動作                                    |
    | --------------------------------- | ----------------------------------------- |
    | [訂閱] 下拉式清單   | 保留預設值。                 |
    | [資源群組] 下拉式清單 | 選取清單中的 [ConfidentialStack]。 |
    | [金鑰保存庫名稱] 文字輸入框       | 輸入 **securevault**[您的名稱]。        |
    | [區域] 下拉式清單         | 選取 [美國東部]  。                       |
    | [定價層] 下拉式清單   | 選取 [標準]。                      |

    下列螢幕擷取畫面顯示 [建立金鑰保存庫] 窗格上的設定。

    ![顯示 [建立金鑰保存庫] 窗格上設定的螢幕擷取畫面](./media/l07_create_key_vault.png)

1. 在 [檢閱 + 建立] 索引標籤上，檢閱在先前步驟中選取的選項。

1. 選取 [建立]，使用您指定的設定建立金鑰保存庫。

    > **注意**：等候建立工作完成，再繼續進行實驗。

#### <a name="task-4-create-a-function-app"></a>工作 4：建立函數應用程式

1. 在 Azure 入口網站中，使用 [搜尋資源、服務和文件] 文字輸入框，搜尋 **函數應用程式**，然後在結果清單中選取 [函數應用程式]。

1. 在 [函數應用程式] 窗格上，選取 [建立]。

1. 在 [建立函數應用程式] 窗格的 [基本] 索引標籤上，執行下列動作，然後選取 [下一步：裝載]：

    | 設定                           | 動作                            |
    | --------------------------------- | --------------------------------- |
    | [訂閱] 下拉式清單   | 保留預設值         |
    | [資源群組] 下拉式清單 | 選取 [ConfidentialStack]     |
    | [函數應用程式名稱] 文字輸入框    | 輸入 **securefunc**[您的名稱] |
    | [發佈] 區段               | 選取 [程式碼] |
    | [執行階段堆疊] 下拉式清單  | 選取 **.NET** |
    | [版本] 下拉式清單        | 選取 **3.1** |
    | [區域] 下拉式清單         | 選取 [美國東部] 區域。 |
    | [作業系統] 選項按鈕 | [選取 Linux] |
    | [方案類型] 下拉式清單      | 選取 [使用量 (無伺服器)] |


1. 在 [裝載] 索引標籤上執行下列動作，然後選取 [檢閱 + 建立]：

    | 設定 | 動作 |
    | --- | --- |
    | [儲存體帳戶] 下拉式清單 | 選取 [securestor[您的名稱]] 儲存體帳戶 |

1. 在 [檢閱 + 建立] 索引標籤上，檢閱在先前步驟中選取的選項。

1. 選取 [建立]，使用您指定的設定來建立函數應用程式。

    > **注意**：等候建立工作完成，再繼續進行實驗。

#### <a name="review"></a>檢閱

在此練習中，您建立了要在此實驗中使用的所有資源。

### <a name="exercise-2-configure-secrets-and-identities"></a>練習 2：設定祕密和身分識別

#### <a name="task-1-configure-a-system-assigned-managed-service-identity"></a>工作 1：設定系統指派的受管理服務識別

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 **ConfidentialStack** 窗格上，選取 [securefunc[您的名稱]] 函數應用程式。

    > **注意**：有兩個資源會具有相同的名稱，分別是函數應用程式和 Application Insights 資源。 請務必選取 [函數應用程式] 資源。

1. 在 [函數應用程式] 窗格上，從 [設定] 區段中選取 [身分識別] 選項。

1. 在 [身分識別] 窗格的 [系統指派] 索引標籤上，將 [狀態] 設為 [開啟]，然後選取 [儲存]。

1. 選取 [是] 以確認設定。

    > **注意**：等候系統指派的受控識別建立完成，再繼續進行此實驗。

#### <a name="task-2-create-a-key-vault-secret"></a>工作 2：建立 Key Vault 祕密

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上，選取 [securevault[您的名稱]] 金鑰保存庫。

1. 在 [金鑰保存庫] 窗格上，選取 [設定] 區段中的 [秘密] 連結。

1. 在 [秘密] 窗格上，選取 [+ 產生/匯入]。

1. 在 [建立祕密] 窗格上執行下列動作，然後選取 [建立]：

    | 設定 | 動作 |
    | --- |  --- |
    | [上傳選項] 下拉式清單 | 选择“手动” |
    | [名稱] 文字輸入框       | 輸入 **storagecredentials** |
    | [值] 文字輸入框       | 輸入您先前在此實驗中記錄的儲存體帳戶連接字串。               |
    | [內容類型] 文字輸入框 | 保留空白。 |
    | [設定啟用日] 核取方塊 | 未選取。 |
    | [設定到期日] 核取方塊 | 未選取。 |
    | [已啟用] 選項 | 選取 [是]  。 |

    下列螢幕擷取畫面顯示 [建立祕密] 窗格上的設定。

    ![顯示 [建立祕密] 窗格上設定的螢幕擷取畫面 ](./media/l07_create_a_secret.png)

    > **注意**：請先等候建立秘密完成，再繼續進行此實驗。

1. 返回 [秘密] 窗格，然後選取清單中的 **storagecredentials** 項目。

1. 在 [版本] 窗格上，選取最新版的 **storagecredentials** 秘密。

1. 在 [秘密版本] 窗格上執行下列動作：

    1. 選取 [顯示秘密值] 以尋找秘密值。

    1. 記錄 [秘密識別碼] 文字輸入框的值，因為您稍後會在實驗室中使用此值。

    > **注意**：您記錄的是 [秘密識別碼] 文字輸入框的值，而不是 [秘密值] 文字輸入框。

#### <a name="task-3-configure-a-key-vault-access-policy"></a>工作 3：設定 Key Vault 存取原則

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上，選取 [securevault[您的名稱]] 金鑰保存庫。

1. 在 [金鑰保存庫] 窗格上，選取 [設定] 區段中的 [存取原則] 連結。

1. 在 [存取原則] 窗格上，選取 [新增存取原則]。

1. 在 [新增存取原則] 窗格上執行下列動作，然後選取 [新增]：

    | 設定 | 動作 |
    | --- | --- |
    | [從範本設定] 下拉式清單 | 保留空白 |
    | [金鑰使用權限] 下拉式清單 | 0 (已選取) |
    | [祕密使用權限] 下拉式清單 | 選取 **GET** 使用權限 |
    | [憑證使用權限] 下拉式清單 | 0 (已選取) |
    | [選取主體] 連結 | 尋找並選取名為 [securefunc[您的名稱]] 的服務主體。 您先前在此實驗中建立的系統指派受控識別，其名稱會與 Azure Function 資源相同。 |
    | [授權的應用程式] 連結 | 尚未選取 |

    下列螢幕擷取畫面顯示 [新增存取原則] 窗格中的設定。

    ![說明 [新增存取原則] 窗格上設定的螢幕擷取畫面。](./media/l07_add_access_policy.png)

1. 在 [存取原則] 窗格上選取 [儲存]。

    > **注意**：等候您對存取原則的變更儲存完成，再繼續進行此實驗。

#### <a name="task-4-create-a-key-vault-derived-application-setting"></a>工作 4：建立自金鑰保存庫衍生的應用程式設定

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上，選取 **securefunc[您的名稱]** 函數應用程式。

1. 在 [函數應用程式] 窗格上，從 [設定] 區段中選取 [設定] 選項。

1. 在 [設定] 窗格的 [應用程式設定] 索引標籤上，選取 [新增應用程式設定]。

1. 在 [新增/編輯應用程式設定] 快顯視窗的 [名稱] 文字輸入框中，輸入 **StorageConnectionString**。

1. 在 [值] 文字輸入框中，使用下列語法來建構值：``@Microsoft.KeyVault(SecretUri=*Secret Identifier*)``

    > **注意**：您必須使用上述語法來組建對 **秘密識別碼** 的參考。 例如，如果您的秘密識別碼是 `https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf`，您的值就會是 `@Microsoft.KeyVault(SecretUri=https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf)`。

1. 將 [部署位置設定] 核取方塊設為其預設值 (未選取)，然後選取 [確定] 以關閉快顯視窗並返回 [設定] 區段。

1. 選取 [儲存] 以儲存您的設定，然後在 [儲存變更] 確認快顯對話方塊中選取 [繼續]。

    > **注意**：等候應用程式設定儲存完成，再繼續進行實驗。

#### <a name="review"></a>檢閱

在此練習中，您為函數應用程式建立了系統指派的受控服務識別，然後授予該身分識別適當的使用權限來取得金鑰保存庫中的秘密值。 最後，您建立了在函數應用程式組態設定中參考的秘密。

### <a name="exercise-3-build-an-azure-functions-app"></a>練習 3：組建 Azure Functions 應用程式

#### <a name="task-1-initialize-a-function-project"></a>工作 1：初始化函式專案

1. 在工作列上，選取 **Windows 終端機** 圖示。

1. 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

    > **注意**：在 [Windows 檔案總管] 中，從 F:\Allfiles\Labs\07\Starter\func\.gitignore 檔案移除 [唯讀] 屬性。

1. 執行下列命令，使用 **Azure Functions Core Tools**，以在目前目錄透過 **dotnet** 執行階段建立新的本機 Functions 專案：

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **注意**：您可以使用 **Azure Functions Core Tools** 檢閱文件以 [建立新專案][azure-functions-core-tools-new-project]。

1. 執行下列命令來 **組建** .NET Core 3.1 專案：

    ```powershell
    dotnet build
    ```

#### <a name="task-2-create-an-http-triggered-function"></a>工作 2：建立 HTTP 觸發函式

1. 執行下列命令，使用 **Azure Functions Core Tools**，透過 **HTTP 觸發** 範本來建立名為 **FileParser** 的新函式：

    ```powershell
    func new --template "HTTP trigger" --name "FileParser"
    ```

    > **注意**：您可以使用 **Azure Functions Core Tools** 檢閱文件以 [建立新函式][azure-functions-core-tools-new-function]。

1. 關閉目前執行中的 **Windows 終端機** 應用程式。

#### <a name="task-3-configure-and-read-an-application-setting"></a>工作 3：設定並讀取應用程式設定

1. 在 [開始] 畫面上選取 [Visual Studio Code] 圖格。 

1. 在 [檔案] 功能表上，選取 [開啟資料夾]。

1. 在開啟的 [檔案總管] 視窗中，瀏覽至 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func**，然後選取 [選取資料夾]。

1. 在 [Visual Studio Code] 視窗的 [Explorer] 窗格上，開啟 **local.settings.json** 檔案。

1. 觀察 **Values** 物件目前的值：

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet"
    }
    ```

1. 新增名為 **StorageConnectionString** 的新設定，然後將其指派為 **[TEST VALUE]** 的字串值，以更新 **Values** 物件的值：

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet",
        "StorageConnectionString": "[TEST VALUE]"
    }
    ```

1. **local.settings.json** 檔案現在應該包含：

    ```json
    {
        "IsEncrypted": false,
        "Values": {
            "AzureWebJobsStorage": "UseDevelopmentStorage=true",
            "FUNCTIONS_WORKER_RUNTIME": "dotnet",
            "StorageConnectionString": "[TEST VALUE]"
        }
    }
    ```

1. 選取 [儲存] 以將您的變更儲存至 **local.settings.json** 檔案。

1. 在 [Visual Studio Code] 視窗的 [Explorer] 窗格上開啟 **FileParser.cs** 檔案。

1. 在程式碼編輯器中觀察範例實作情況：

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    namespace func
    {
        public static class FileParser
        {
            [FunctionName("FileParser")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
                string name = req.Query["name"];
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. 刪除 **FileParser.cs** 檔案中的所有內容。

1. 新增下列程式碼，為 **Microsoft.AspNetCore.Mvc**、**Microsoft.Azure.WebJobs**、**Microsoft.AspNetCore.Http**、**System** 和 **System.Threading.Tasks** 命名空間新增 **using 指示詞**：

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    ```

1. 建立名為 **FileParser** 的新 **公用靜態** 類別：

    ```csharp
    public static class FileParser
    { }
    ```

1. 再次觀察 **FileParser.cs** 檔案，現在應該包含：

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    { }
    ```

1. 在 **FileParser** 類別內新增下列程式碼區塊，以建立名為 **Run** 的新 **公用靜態** 非同步方法。 此方法會傳回 **Task\<IActionResult\>** 類型的變數，並接收 **HttpRequest** 類型的變數，名為 request：

    ```csharp
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. 新增下列程式碼，將屬性附加至 **FunctionNameAttribute** 類型的 **Run** 方法，其 **名稱** 參數的值設為 **FileParser**：

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. 新增下列程式碼，將屬性附加至 **HttpTriggerAttribute** 型別的 **要求** 參數，其 **方法** 參數陣列設為單一值 **GET**：

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        [HttpTrigger("GET")] HttpRequest request)
    { }
    ```

1. 再次觀察 **FileParser.cs** 檔案，現在應該包含：

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        { }
    }
    ```

1. 在 **Run** 方法中輸入下列程式碼，以使用 **Environment.GetEnvironmentVariable** 方法來擷取 **StorageConnectionString** 應用程式設定的值，並將結果儲存在名為 **connectionString** 的 **字串** 變數中：

    ```csharp
    string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
    ```

1. 輸入下列程式碼，以傳回 **connectionString** 變數的值作為 HTTP 回應：

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. 再次觀察 **FileParser.cs** 檔案，現在應該包含：

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

1. 選取 [儲存] 將您的變更儲存至 **FileParser.cs** 檔案。

#### <a name="task-4-validate-the-local-function"></a>工作 4：驗證本機函式

1. 在工作列上，選取 **Windows 終端機** 圖示。

1. 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. 執行下列命令以執行函數應用程式專案：

    ```powershell
    func start --build
    ```

    > **注意**：您可以使用 **Azure Functions Core Tools** 檢閱文件以 [在本機啟動函數應用程式專案][azure-functions-core-tools-start-function]。

1. 在工作列上，再次選取 **Windows 終端機** 圖示以開啟 **Windows 終端機** 應用程式的新執行個體。 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```
    
1. 當您收到開啟的命令提示字元時，請執行下列命令來啟動 **httprepl** 工具，將基礎統一資源識別項 (URI) 設為 ``http://localhost:7071``：

    ```powershell
    httprepl http://localhost:7071
    ```

    > **注意**：**httprepl** 工具會顯示錯誤訊息。 會出現此訊息是因為該工具會搜尋要用來周遊 API 的 Swagger 定義檔。 您的函式專案不會產生 Swagger 定義檔，因此您必須手動周遊 API。
1. 當您收到工具提示時，請執行下列命令來瀏覽至相應的 **api** 目錄：

    ```powershell
    cd api
    ```

1. 執行下列命令以瀏覽至相應的 **fileparser** 目錄：

    ```powershell
    cd fileparser
    ```

1. 執行下列命令來執行 **get** 命令：

    ```powershell
    get
    ```

1. 觀察以 HTTP 要求的形式回傳的 **StorageConnectionString** [TEST VALUE] 值：

    ```powershell
    HTTP/1.1 200 OK
    Content-Type: text/plain; charset=utf-8
    Date: Tue, 01 Sep 2020 23:35:39 GMT
    Server: Kestrel
    Transfer-Encoding: chunked
    [TEST VALUE]
    ```

1. 執行下列命令即可結束 **httprepl** 工具：

    ```powershell
    exit
    ```

1. 關閉 **Windows 終端機** 應用程式目前執行中的所有執行個體。

#### <a name="task-5-deploy-the-function-using-the-azure-functions-core-tools"></a>工作 5：使用 Azure Functions Core Tools 部署函式

1. 在工作列上，選取 **Windows 終端機** 圖示。

1. 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. 執行下列命令以登入 Azure 命令列介面 (CLI)：

    ```powershell
    az login
    ```

1. 在 **Microsoft Edge** 瀏覽器視窗中，輸入 Microsoft 帳戶的電子郵件地址和密碼，然後選取 [登入]。

1. 返回目前開啟的 [Windows 終端機] 視窗。 等候登入流程完成。

1. 執行下列命令以發佈函數應用程式專案：

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **注意**：舉例來說，如果您的 **函數應用程式名稱** 是 **securefuncstudent**，您的命令會是 ``func azure functionapp publish securefuncstudent``。 您可以使用 **Azure Functions Core Tools** 檢閱文件以 [發佈本機函數應用程式專案][azure-functions-core-tools-publish-azure]。

1. 等候部署完成，再繼續進行實驗。

1. 關閉目前執行中的 **Windows 終端機** 應用程式。

#### <a name="task-6-test-the-key-vault-derived-application-setting"></a>工作 6：測試自金鑰保存庫衍生的應用程式設定

1. 在工作列上選取 **Microsoft Edge** 圖示，然後選取包含 Azure 入口網站 (<https://portal.azure.com>) 的索引標籤。

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上，選取 **securefunc[您的名稱]** 函數應用程式。

1. 在 [函數應用程式] 窗格上，選取 [函式] 區段中的 [函式] 選項。

1. 在 [函式] 窗格上，選取現有的 **FileParser** 函式。

1. 在 [函式] 窗格上，選取 [開發人員] 區段中的 [程式碼 + 測試] 選項。

1. 在函式編輯器中選取 [測試/執行]。

1. 在顯示的快顯對話方塊中，選取 [HTTP 方法] 清單中的 [GET]。

1. 選取 [執行] 以測試函式。

1. 觀察測試回合的結果。 結果應該是您的 Azure 儲存體連接字串。

#### <a name="review"></a>檢閱

在此練習中，您使用了服務識別來讀取儲存在 Key Vault 中的秘密值，並將該值作為函數應用程式的結果傳回。

### <a name="exercise-4-access-azure-blob-storage-data"></a>練習 4：存取 Azure Blob 儲存體資料

#### <a name="task-1-upload-a-sample-storage-blob"></a>工作 1：上傳範例 Blob 儲存體

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上選取 [securefunc[您的名稱]] 儲存體帳戶。

1. 在 [儲存體帳戶] 窗格的 [資料儲存體] 區段中，選取 [容器] 連結。

1. 在 [容器] 區段中選取 [+ 容器]。

1. 在 [新增容器] 快顯視窗中執行下列動作，然後選取 [建立]：

    | 設定 | 動作 |
    | --- | --- |
    | [名稱] 文字輸入框 | 輸入 **drop** |
    | [公用存取層級] 下拉式清單 | 選取 [Blob (僅限 Blob 的匿名讀取存取)]。 |

1. 返回 [容器] 區段，然後選取最新建立的 **drop** 容器。

1. 在 [容器] 窗格上，選取 [上傳]。

1. 在 [上傳 blob] 視窗中，執行下列動作，然後選取 [上傳]：

    | 設定 | 動作 |
    | --- | --- |
    | [檔案] 區段 | 選取 **資料夾** 圖示。 |
    | [檔案總管] 視窗 | 瀏覽至 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter**，選取 **records.json** 檔案，然後選取 [開啟]。 |
    | [如果檔案已存在即覆寫檔案] 核取方塊 | 請務必選取此核取方塊。 |

    > **注意**：等候 blob 上傳後，再繼續實驗。

1. 返回 [容器] 窗格，然後在 Blob 清單中選取 **records.json** Blob。

1. 在 [Blob] 窗格上尋找 Blob 中繼資料，然後複製 Blob 的 URL。

1. 在工作列上，啟動 **Microsoft Edge** 圖示的捷徑功能表，然後選取 [新增視窗]。

1. 在新的瀏覽器視窗中，參考您為 Blob 複製的 URL。

1. 現在應該會顯示 Blob 的 JavaScript 物件標記法 (JSON) 內容。 將顯示 JSON 內容的瀏覽器視窗關閉。

1. 返回內含 Azure 入口網站的瀏覽器視窗，然後關閉 [Blob] 窗格。

1. 返回 [容器] 窗格，然後選取 [變更存取層級]。

1. 在 [變更存取層級] 快顯視窗中執行下列動作：

    1. 在 [公用存取層級] 下拉式清單中，選取 [私人 (沒有匿名存取)]。

    1. 選取 [確定]。

1. 在工作列上，啟動 **Microsoft Edge** 圖示的捷徑功能表，然後選取 [新增視窗]。

1. 在新的瀏覽器視窗中，參考您為 Blob 複製的 URL。

1. 現在應該會顯示找不到資源的錯誤訊息。

    > **注意**：如果錯誤訊息未顯示，您的瀏覽器可能已經快取檔案。 選取 [Ctrl+F5] 即可重新整理頁面，直到顯示錯誤訊息為止。

#### <a name="task-2-pull-and-configure-the-azure-sdk-for-net"></a>工作 2：提取並設定 Azure SDK for .NET

1. 在工作列上，選取 **Windows 終端機** 圖示。

1. 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. 執行下列命令即可從 NuGet 新增 **12.6.0** 版的 **Azure.Storage.Blobs** 套件：

    ```powershell
    dotnet add package Azure.Storage.Blobs --version 12.6.0
    ```

    > **注意**：[Azure.Storage.Blobs](https://www.nuget.org/packages/Azure.Storage.Blobs/12.6.0) NuGet 套件參考了撰寫 Azure Blob 儲存體程式碼所需的 Azure SDK for .NET 子集。

1. 關閉目前執行中的 **Windows 終端機** 應用程式。

1. 在 [開始] 畫面上選取 [Visual Studio Code] 圖格。 

1. 在 [檔案] 功能表上，選取 [開啟資料夾]。

1. 在開啟的 [檔案總管] 視窗中，瀏覽至 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func**，然後選取 [選取資料夾]。

1. 在 [Visual Studio Code] 視窗的 [Explorer] 窗格上開啟 **FileParser.cs** 檔案。

1. 為 **Azure.Storage.Blobs** 命名空間新增 **using 指示詞**：

    ```csharp
    using Azure.Storage.Blobs;
    ```

1. 觀察 **FileParser.cs** 檔案，現在應該包含：

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

#### <a name="task-3-write-azure-blob-storage-code-using-the-azure-sdk-for-net"></a>工作 3：使用 Azure SDK for .NET 撰寫 Azure Blob 儲存體程式碼

1. 在 **FileParser** 類別的 **Run** 方法中，刪除下列程式碼：

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. 同樣在 **Run** 方法中，新增下列程式碼區塊，透過傳入 *connectionString* 變數、``"drop"`` 字串值和 ``"records.json"`` 字串值至建構函式，來建立 **BlobClient** 類別的新執行個體：

    ```csharp
    BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
    ```

1. 同樣在 **Run** 方法中，新增下列程式碼區塊，使用 **BlobClient.DownloadAsync** 方法非同步下載所參考的 Blob 內容，然後將結果儲存在名為 response 的變數中：

    ```csharp
    var response = await blob.DownloadAsync();
    ```

1. 同樣在 **Run** 方法中，新增下列程式碼區塊，使用 **FileStreamResult** 類別建構函式傳回儲存在「內容」變數中的各種內容值：

    ```csharp
    return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
    ```

1. 再次觀察 **FileParser.cs** 檔案，現在應該包含：

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
            var response = await blob.DownloadAsync();
            return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
        }
    }
    ```

1. 選取 [儲存] 將您的變更儲存至 **FileParser.cs** 檔案。

#### <a name="task-4-deploy-and-validate-the-azure-functions-app"></a>工作 4：部署並驗證 Azure Functions 應用程式

1. 在工作列上，選取 **Windows 終端機** 圖示。

1. 執行下列命令，將目前目錄變更為 **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** 空白目錄：

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. 執行下列命令以登入 Azure CLI：

    ```powershell
    az login
    ```
1. 在 **Microsoft Edge** 瀏覽器視窗中，輸入 Microsoft 帳戶的電子郵件地址和密碼，然後選取 [登入]。

1. 返回目前開啟的 [Windows 終端機] 視窗。 等候登入流程完成。

1. 執行下列命令以再次發佈函數應用程式專案：

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **注意**：舉例來說，如果您的 **函數應用程式名稱** 是 **securefuncstudent**，您的命令會是 ``func azure functionapp publish securefuncstudent``。 您可以使用 **Azure Functions Core Tools** 檢閱文件以 [發佈本機函數應用程式專案][azure-functions-core-tools-publish-azure]。

1. 等候部署完成，再繼續進行實驗。

1. 關閉目前執行中的 **Windows 終端機** 應用程式。

1. 在工作列上選取 **Microsoft Edge** 圖示，然後參考 Azure 入口網站 (<https://portal.azure.com>)。

1. 在 Azure 入口網站的 [瀏覽] 窗格上，選取 [資源群組] 連結。

1. 在 [資源群組] 窗格上，選取 [ConfidentialStack] 資源群組。

1. 在 [ConfidentialStack] 窗格上，選取 **securefunc[您的名稱]** 函數應用程式。

1. 在 [App Service] 窗格上，選取 [函式] 區段中的 [函式] 選項。

1. 在 [函式] 窗格上，選取現有的 **FileParser** 函式。

1. 在 [函式] 窗格上，選取 [開發人員] 區段中的 [程式碼 + 測試] 選項。

1. 在函式編輯器中選取 [測試/執行]。

1. 在顯示的快顯對話方塊中，選取 [HTTP 方法] 清單中的 [GET]。

1. 選取 [執行] 以測試函式。

1. 觀察測試回合的結果。 輸出會包含儲存在 Azure 儲存體帳戶中的 **$/drop/records.json** Blob 內容。

#### <a name="review"></a>檢閱

在此練習中，您使用了 C\# 程式碼來存取儲存體帳戶，然後下載了 Blob 的內容。

### <a name="exercise-5-clean-up-your-subscription"></a>練習 5：清除訂閱

#### <a name="task-1-open-azure-cloud-shell"></a>工作 1：開啟 Azure Cloud Shell

1. 在 Azure 入口網站中，選取 **Cloud Shell** 圖示 ![Cloud Shell 圖示](./media/az204_lab_CloudShell.png) ，開啟新的 Bash 工作階段。 如果 Cloud Shell 預設為 PowerShell 工作階段，請選取 [PowerShell]，然後在下拉式功能表中選取 [Bash]。

    > **注意**：如果這是您第一次啟動 **Cloud Shell**，當系統提示您選取 [Bash] 或 [PowerShell] 時，請選取 [PowerShell]。   系統顯示 **您未裝載儲存體** 訊息時，請選取此實驗中使用的訂閱，然後選取 [建立儲存體]。

#### <a name="task-2-delete-a-resource-group"></a>工作 2：刪除資源群組

1. 在 [Cloud Shell] 窗格上，執行下列命令刪除 **ConfidentialStack** 資源群組：

    ```bash
    az group delete --name ConfidentialStack --no-wait --yes
    ```

     > **注意**：此命令會以非同步方式執行 (由 --nowait 參數決定)，所以雖然您可以在同一個 Bash 工作階段中立即執行另一個 Azure CLI 命令，但系統需要幾分鐘才會實際移除資源群組。

1. 關閉入口網站中的 [Cloud Shell] 窗格。

#### <a name="task-3-close-the-active-application"></a>工作 3：關閉作用中的應用程式

- 關閉目前執行中的 Microsoft Edge 應用程式。

#### <a name="review"></a>檢閱

在此練習中，您已移除此實驗中使用的資源群組，並清除了您的訂閱。
